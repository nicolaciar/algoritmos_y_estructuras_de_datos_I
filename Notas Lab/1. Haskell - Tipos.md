

---

# üß† **1. ¬øQu√© es un tipo en Haskell?**

Un **tipo** es una _clasificaci√≥n est√°tica_ de valores. Cada expresi√≥n en Haskell pertenece a un tipo, que determina:

- **qu√© valores puede tomar**
    
- **qu√© operaciones puedes hacer con √©l**
    
- **c√≥mo se interpreta en memoria o en el lenguaje**
    

Como en matem√°ticas, el tipo describe el ‚Äúdominio‚Äù de los valores con los que trabaja la funci√≥n.

Por ejemplo:

```haskell
5 :: Int
"hola" :: String
True :: Bool
```

En Haskell, **los tipos son est√°ticos y se verifican antes de ejecutar el programa**: ning√∫n programa bien tipado puede fallar en tiempo de ejecuci√≥n por problemas de tipos (al menos no por eso).

---

# üéØ **2. Tipado fuerte y est√°tico**

Haskell tiene dos propiedades clave:

### ‚úî Tipado est√°tico

El tipo de toda expresi√≥n debe ser conocido **en tiempo de compilaci√≥n**.

No puede ocurrir:

```haskell
x = 5
x = "hola"   -- ‚ùå imposible
```

### ‚úî Tipado fuerte

Nunca puedes ‚Äúforzar‚Äù una operaci√≥n entre tipos incompatibles:

```haskell
5 + "hola"  -- ‚ùå jam√°s compila
```

Esto es muy distinto de lenguajes como Python o JS, que pueden mezclar cosas en tiempo de ejecuci√≥n.

---

# üß± **3. Tipos b√°sicos (primitivos)**

Los m√°s elementales, provistos por la biblioteca est√°ndar:

|Tipo|Descripci√≥n|
|---|---|
|`Int`|Entero de tama√±o fijo (palabra de m√°quina)|
|`Integer`|Entero arbitrario, sin l√≠mite te√≥rico|
|`Float`, `Double`|Reales de punto flotante|
|`Bool`|`True` / `False`|
|`Char`|Un car√°cter|
|`String`|Alias de `[Char]`|

Ejemplos:

```haskell
42       :: Int
1234567  :: Integer
3.14     :: Double
'a'      :: Char
"hola"   :: String
```

---

# üì¶ **4. Tipos compuestos (estructurados)**

Estos se construyen a partir de otros.

## **a) Tuplas**

```haskell
(3, "a")        :: (Int, String)
(True, 2.5, 'c') :: (Bool, Double, Char)
```

Son **heterog√©neas y de tama√±o fijo**.

## **b) Listas**

```haskell
[1, 2, 3] :: [Int]
"hola"   :: [Char]
```

Las listas son **homog√©neas y de tama√±o din√°mico**, pero responden a una misma estructura recursiva:

```haskell
[]                 -- lista vac√≠a
x : xs             -- un elemento seguido de otra lista
```

---

# ‚ú® **5. Tipos algebraicos (ADTs)**

Haskell permite **definir nuevos tipos**, combin√°ndolos por suma o producto.

Ejemplo: producto (struct-like)

```haskell
data Punto = P Float Float
```

Ejemplo: suma (enum-like)

```haskell
data Color = Rojo | Verde | Azul
```

Ejemplo sum + product:

```haskell
data Figura
    = Circulo Float
    | Rectangulo Float Float
```

Estos son **la esencia del dise√±o de datos en Haskell**: permiten representar estructuras ricas con sem√°ntica clara y verificaci√≥n est√°tica.

---

# üß© **6. Sin√≥nimos de tipos (type synonyms)**

No generan nuevos valores, solo **nombres alternativos**:

```haskell
type Nombre = String
type Edad = Int
```

Son √∫tiles para documentaci√≥n y claridad.

---

# üéöÔ∏è **7. Polimorfismo param√©trico**

Una funci√≥n puede ser **general para cualquier tipo**, sin depender de su contenido.

Ejemplo cl√°sico:

```haskell
id :: a -> a
id x = x
```

`a` es un **par√°metro de tipo**: no sabemos qu√© es, pero no importa para la funci√≥n.

Otro ejemplo:

```haskell
length :: [a] -> Int
```

`length` no necesita saber el contenido de la lista.

üëâ Este polimorfismo es **puro**, no inspecciona valores, solo estructura.

---

# üè∑Ô∏è **8. Polimorfismo por clases de tipos (typeclasses)**

Permite **sobrecargar funciones** seg√∫n qu√© operaciones sean v√°lidas para un tipo.

Ejemplos:

```haskell
(+) :: Num a => a -> a -> a
```

La restricci√≥n `Num a =>` indica:

> ‚Äúesto funciona para cualquier tipo `a` que sea instancia de la clase `Num`‚Äù

Esto no es polimorfismo param√©trico puro, sino **adyacente a ad-hoc**.

Las clases de tipos fundamentales:

- `Eq` (comparaci√≥n)
    
- `Ord` (orden total)
    
- `Show` (conversion a string)
    
- `Read` (parseo desde string)
    
- `Num`, `Fractional` (operaciones num√©ricas)
    

Los ADTs pueden ser instancias:

```haskell
data Color = Rojo | Verde | Azul deriving (Show, Eq)
```

---

# üö¶ **9. Naturaleza de los tipos en Haskell**

Consideraciones profundas:

### ‚úî Los tipos describen el comportamiento sem√°ntico, no la representaci√≥n f√≠sica

Ejemplo: `Bool` es matem√°ticamente:

```haskell
data Bool = True | False
```

No importa c√≥mo se represente en bits.

### ‚úî Los tipos son parte del lenguaje

Esto no es como en C o Java donde el ‚Äútipo‚Äù es m√°s incidental. En Haskell:

- los tipos forman su propia sintaxis
    
- hay **funciones entre tipos**
    
- el compilador los prueba como si fueran teoremas
    

### ‚úî El sistema de tipos es rico

No solo verifica compatibilidad: **infieren, abstraen y garantizan propiedades sem√°nticas**.

---

# üìè **10. Consideraciones importantes de dise√±o**

Como buen  matem√°tico :

- **Evita usar `String` cuando puedas usar nuevos tipos**  
    M√°s sem√°ntica, menos errores.
    
- **Prefiere Integer a Int si necesitas seguridad num√©rica**
    
- **Dise√±a tus propios ADTs** en lugar de estructuras sueltas
    
- **Aprovecha typeclasses** para evitar duplicaci√≥n
    
- **Piensa los tipos como invariantes**  
    Cada tipo expresa condiciones sem√°nticas del problema.
    
- **Especificar tipos es parte del contrato**  
    No solo ‚Äúdocumenta‚Äù: **el compilador prueba su validez**.
    

---

# ‚≠ê **11. C√≥mo leer firmas de tipo**

Si ves:

```haskell
f :: Num a => a -> a -> a
```

Esto significa:

> Para cualquier `a` que tenga operaciones num√©ricas v√°lidas, `f` toma dos valores de tipo `a` y devuelve otro de tipo `a`.

Si ves:

```haskell
map :: (a -> b) -> [a] -> [b]
```

Esto significa:

> Dada una funci√≥n que transforma `a` en `b`, produce una lista transformada.

---
